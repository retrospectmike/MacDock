#include "DockCoreUpdate.h"/// Globals ///FSSpec gFSSpec_arr[MAX_DOCK_ITEM_COUNT]; unsigned short gFSSpec_cnt = 0;void FlashItem(unsigned short item_num){	WindowPtr dockWin= thePort; //should be a better handle on the dock window	Rect itemRect;	long startTicks; //ticks = 1/60 of a second	short blinkCnt = 0;		itemRect.left = (kDockHSpace+kDockIconWidth+kDockHSpace)*item_num;	itemRect.right = itemRect.left + (kDockHSpace+kDockIconWidth+kDockHSpace);	itemRect.top = kDockVSpace;	itemRect.bottom = itemRect.top + kDockIconHeight;	while(blinkCnt < kBlinksOnClick){		InvertRect(&itemRect);		startTicks = TickCount();		while((TickCount()-startTicks) < kTicksBtwBlink) ;		InvertRect(&itemRect);		startTicks = TickCount();		while((TickCount()-startTicks) < kTicksBtwBlink) ;		blinkCnt = blinkCnt+1;	}}void InvertItem(unsigned short item_num){	WindowPtr dockWin= thePort; //should be a better handle on the dock window	Rect itemRect;		itemRect.left = (kDockHSpace+kDockIconWidth+kDockHSpace)*item_num;	itemRect.right = itemRect.left + (kDockHSpace+kDockIconWidth+kDockHSpace);	itemRect.top = kDockVSpace;	itemRect.bottom = itemRect.top + kDockIconHeight;	InvertRect(&itemRect);}/* LaunchApp () * Returns true if there was an app * in slot item_num else false  */ Boolean LaunchApp(unsigned short item_num){	//do gestalt check gestaltOSAttr to see if sys supports the modern Launch records first...	LaunchParamBlockRec launchPBR;	if(gFSSpec_cnt <= item_num)		return false;	launchPBR.launchBlockID = extendedBlock; //const indicating you're launching	launchPBR.launchEPBLength = extendedBlockLen; //const specifying size, also from Processes.h	//no need to set the  .launchFileFlags because using extendedBlock	launchPBR.launchControlFlags = launchContinue;	launchPBR.launchAppSpec = &(gFSSpec_arr[item_num]);	FlashItem(item_num);	LaunchApplication(&launchPBR);	return true;}/** OldOpenApp is defunct -- it was an attempt to use appleevents  to do this app's job before I knew about LaunchApplication() **/void OpenApp(){	OSErr err;	AEAddressDesc addressDesc;	OSType appSig;	AppleEvent appleEvent, reply;		appSig = 'Prmr';	err = AECreateDesc(typeApplSignature, (Ptr)(&appSig),				(Size)sizeof(appSig), &addressDesc);	err = AECreateAppleEvent(kCoreEventClass, kAEOpenApplication, 							&addressDesc,							kAutoGenerateReturnID, 1L,							&appleEvent);	err = AESend( &appleEvent, &reply, 				kAENoReply+kAECanInteract,				kAENormalPriority,				kAEDefaultTimeout, 				nil, nil);	//AECreateDesc(...);	//AECreateAppleEvent(...);	//AESend(...);}void UpdateRunningApps(){	ProcessInfoRec procInfoRec;	Str255 procName;	FSSpec appFileLoc; //includes member .vRefNum the vol ref number	OSErr osErr;	ProcessSerialNumber PSN;	DTPBRec DTPBRecord;	Str255 iconData;//128 of (32x32) b&w pixels, 						//and128 ( 32x32) mask bits as two 128-bit-char arrays	Str255 vol_name;	//ParamBlockRec PBRecord;	BitMap b ;	short num_apps = 0;	short debug;	Rect dock_bounds;	Handle handle;	//(Rect){&thePort->rect	dock_bounds.top=kDockVSpace; 	dock_bounds.left=kDockHSpace;	dock_bounds.bottom=dock_bounds.top+kDockIconHeight; 	dock_bounds.right = dock_bounds.left+kDockIconWidth;	b.baseAddr = (Ptr)iconData;// {nil,4,{0,0,32,32}};	b.rowBytes = 4;	b.bounds.top=0;	b.bounds.left=0;	b.bounds.bottom=kDockIconHeight;	b.bounds.right=kDockIconWidth;		procInfoRec.processAppSpec = &appFileLoc;	procInfoRec.processName = (StringPtr)(&procName);	PSN.highLongOfPSN = 0;	PSN.lowLongOfPSN = kNoProcess;	/**** Setup ParamBlock ****/	//PBRecord.ioCompletion = nil;	/**** Setup DTPBRecord ****/	DTPBRecord.ioCompletion = nil;	DTPBRecord.ioNamePtr = nil;	DTPBRecord.ioDTRefNum = 0; //needs desktop db ref #!!!	DTPBRecord.ioTagInfo = 0; //must be 0, RESERVED	DTPBRecord.ioDTBuffer = (Ptr)(iconData);	DTPBRecord.ioDTReqCount = kLargeIconSize; //or 256 for bitmap + mask?	DTPBRecord.ioIconType = kLargeIcon;		//Check that this desktop has a desktop database else quit:		//PBGetVol((ParmBlkPtr)(&PBRecord),true);	//PBHGetVolParms(...) ; and check the bHasDesktopMgr bit- see 1992-files.pdf::pg2-148	//if(bHasDesktopMgr bit on) then...:	//  then call PBDTGetPath() or PBDTOpenInform() to access path to a DB		gFSSpec_cnt = 0;	while(GetNextProcess(&PSN) == noErr)	{		osErr = GetProcessInformation(&PSN,								(ProcessInfoRecPtr)(&procInfoRec));		if(procInfoRec.processType == 'APPL'||			procInfoRec.processType == 'FNDR')		{			//look up its icon and get ready to update the dock			DTPBRecord.ioFileCreator = procInfoRec.processSignature; //get the creator from the signature			DTPBRecord.ioFileType = procInfoRec.processType;//get the app icon			DTPBRecord.ioVRefNum = procInfoRec.processAppSpec->vRefNum;			PBDTGetPath((DTPBPtr)(&DTPBRecord));			if(noErr != DTPBRecord.ioResult)			{				SysBeep(10);			 	ExitToShell();			}						//save the FSSPec and update the count:			gFSSpec_arr[gFSSpec_cnt] = *(procInfoRec.processAppSpec);			gFSSpec_cnt = gFSSpec_cnt+1;						PBDTGetIcon((DTPBPtr)(&DTPBRecord),false);						if(DTPBRecord.ioResult != noErr ||				DTPBRecord.ioDTActCount != 256){ //typ. full size b&w icon				if(procInfoRec.processSignature == 'MACS'){					handle=GetIcon(kFinderICON_ID);					PlotIcon(&dock_bounds,handle);//draw a square with the app name on it\					ReleaseResource(handle);				}				else{					handle=GetIcon(kGenAppICON_ID);					PlotIcon(&dock_bounds,handle);//draw a square with the app name on it\					ReleaseResource(handle);				}			}			else //draw a blank square for the app without an icon..				CopyBits(&b,&thePort->portBits,&b.bounds,&dock_bounds,srcCopy,nil);						num_apps++;			dock_bounds.left+=kDockHSpace+kDockIconWidth+kDockHSpace;			dock_bounds.right+=kDockHSpace+kDockIconWidth+kDockHSpace;		}	}	//And Erase the rest of the dock (re-use dock_bounds var):	dock_bounds.bottom=(thePort->portRect).bottom;	dock_bounds.bottom=thePort->portRect.right;	EraseRect(&dock_bounds);}