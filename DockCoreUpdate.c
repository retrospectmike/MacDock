#include "DockCoreUpdate.h"/// Globals ///FSSpec gFSSpec_arr[MAX_DOCK_ITEM_COUNT];	/*FSSpec for running apps*/unsigned short gFSSpec_cnt = 0;				/*Count of running apps*/extern Boolean gShowSelf;extern unsigned short gMacDockItemNum;/* FlashItem * Flashes a Dock item e.g. as UI feedback. * Number of flashes and pauses between flashes * are dictated by constants kBlinksOnClick and * constant kTicksBtwBlink.  See .h file. */void FlashItem(unsigned short item_num){	WindowPtr dockWin= thePort; //should be a better handle on the dock window	Rect itemRect;	long startTicks; //ticks = 1/60 of a second	short blinkCnt = 0;		itemRect.left = (kDockHSpace+kDockIconWidth+kDockHSpace)*item_num;	itemRect.right = itemRect.left + (kDockHSpace+kDockIconWidth+kDockHSpace);	itemRect.top = kDockVSpace;	itemRect.bottom = itemRect.top + kDockIconHeight;	while(blinkCnt < kBlinksOnClick){		InvertRect(&itemRect);		startTicks = TickCount();		while((TickCount()-startTicks) < kTicksBtwBlink) ;		InvertRect(&itemRect);		startTicks = TickCount();		while((TickCount()-startTicks) < kTicksBtwBlink) ;		blinkCnt = blinkCnt+1;	}}/* Invertitem * Inverts the section corresponding to  * the item number specified by (item_num) * This can be used for UI feedback to user */void InvertItem(unsigned short item_num){	WindowPtr dockWin= thePort; //should be a better handle on the dock window	Rect itemRect;		itemRect.left = (kDockHSpace+kDockIconWidth+kDockHSpace)*item_num;	itemRect.right = itemRect.left + (kDockHSpace+kDockIconWidth+kDockHSpace);	itemRect.top = kDockVSpace;	itemRect.bottom = itemRect.top + kDockIconHeight;	InvertRect(&itemRect);}/* LaunchApp  * Tries to launch the app in slot (item_num). * Returns true if there was a non-MacDock app * in that slot or else false  */ Boolean LaunchApp(unsigned short item_num){	//do gestalt check gestaltOSAttr to see if sys supports the modern Launch records first...	LaunchParamBlockRec launchPBR;	if(gFSSpec_cnt <= item_num) return false;	if(item_num == gMacDockItemNum)	{	//Flash self icon and fail to launch		FlashItem(item_num);		return false;	//which should trigger upstream un-hide if nec.	}	launchPBR.launchBlockID = extendedBlock; //const indicating you're launching	launchPBR.launchEPBLength = extendedBlockLen; //const specifying size, also from Processes.h	//no need to set the  .launchFileFlags because using extendedBlock	launchPBR.launchControlFlags = launchContinue;	launchPBR.launchAppSpec = &(gFSSpec_arr[item_num]);	FlashItem(item_num);	LaunchApplication(&launchPBR);	return true;}/** OldOpenApp is defunct -- it was an attempt to use appleevents  to do this app's job before I knew about LaunchApplication() **/void OpenApp(){	OSErr err;	AEAddressDesc addressDesc;	OSType appSig;	AppleEvent appleEvent, reply;		appSig = 'Prmr';	err = AECreateDesc(typeApplSignature, (Ptr)(&appSig),				(Size)sizeof(appSig), &addressDesc);	err = AECreateAppleEvent(kCoreEventClass, kAEOpenApplication, 							&addressDesc,							kAutoGenerateReturnID, 1L,							&appleEvent);	err = AESend( &appleEvent, &reply, 				kAENoReply+kAECanInteract,				kAENormalPriority,				kAEDefaultTimeout, 				nil, nil);	//AECreateDesc(...);	//AECreateAppleEvent(...);	//AESend(...);}/* UpdateRunningApps * This is the core function to update the Dock contents * with the current running apps.   * It does so by repeated queries to GetNextProcess * Accounts for the Finder not technically being an APPL type * Relies on constants kDockHSpace and kDockIconWidth  * and kDockIconHeight to determine the spacing.  See .h file. */ void UpdateRunningApps(){	ProcessInfoRec procInfoRec;	Str255 procName;	FSSpec appFileLoc; //includes member .vRefNum the vol ref number	OSErr osErr;	ProcessSerialNumber PSN;	DTPBRec DTPBRecord;	Str255 iconData;//128 of (32x32) b&w pixels, 						//and128 ( 32x32) mask bits as two 128-bit-char arrays	Str255 vol_name;	//ParamBlockRec PBRecord;	BitMap b ;	short num_apps = 0;	short debug;	Rect dock_bounds;	Handle handle;	//(Rect){&thePort->rect	dock_bounds.top=kDockVSpace; 	dock_bounds.left=kDockHSpace;	dock_bounds.bottom=dock_bounds.top+kDockIconHeight; 	dock_bounds.right = dock_bounds.left+kDockIconWidth;	b.baseAddr = (Ptr)iconData;// {nil,4,{0,0,32,32}};	b.rowBytes = 4;	b.bounds.top=0;	b.bounds.left=0;	b.bounds.bottom=kDockIconHeight;	b.bounds.right=kDockIconWidth;		procInfoRec.processAppSpec = &appFileLoc;	procInfoRec.processName = (StringPtr)(&procName);	PSN.highLongOfPSN = 0;	PSN.lowLongOfPSN = kNoProcess;	/**** Setup ParamBlock ****/	//PBRecord.ioCompletion = nil;	/**** Setup DTPBRecord ****/	DTPBRecord.ioCompletion = nil;	DTPBRecord.ioNamePtr = nil;	DTPBRecord.ioDTRefNum = 0; //needs desktop db ref #!!!	DTPBRecord.ioTagInfo = 0; //must be 0, RESERVED	DTPBRecord.ioDTBuffer = (Ptr)(iconData);	DTPBRecord.ioDTReqCount = kLargeIconSize; //or 256 for bitmap + mask?	DTPBRecord.ioIconType = kLargeIcon;		//Future: check that this desktop has a desktop database else quit		gFSSpec_cnt = 0; //reset app count	while(GetNextProcess(&PSN) == noErr)	{		osErr = GetProcessInformation(&PSN,								(ProcessInfoRecPtr)(&procInfoRec));		if(procInfoRec.processType == 'APPL'||			procInfoRec.processType == 'FNDR')		if(procInfoRec.processSignature != 'MCDK'||gShowSelf)		{			//look up its icon and get ready to update the dock			DTPBRecord.ioFileCreator = procInfoRec.processSignature; //get the creator from the signature			DTPBRecord.ioFileType = procInfoRec.processType;//get the app icon			DTPBRecord.ioVRefNum = procInfoRec.processAppSpec->vRefNum;			PBDTGetPath((DTPBPtr)(&DTPBRecord));			if(noErr != DTPBRecord.ioResult)			{				SysBeep(10);			 	ExitToShell();			}						//save the FSSPec and update the count:			gFSSpec_arr[gFSSpec_cnt] = *(procInfoRec.processAppSpec);			gFSSpec_cnt = gFSSpec_cnt+1;						PBDTGetIcon((DTPBPtr)(&DTPBRecord),false);						if(procInfoRec.processSignature == 'MCDK') //save my location in the dock				gMacDockItemNum = gFSSpec_cnt-1;							if(DTPBRecord.ioResult != noErr ||				DTPBRecord.ioDTActCount != 256)			{ //typ. full size b&w icon				if(procInfoRec.processSignature == 'MACS'){					handle=GetIcon(kFinderICON_ID);					PlotIcon(&dock_bounds,handle);//draw a square with the app name on it\					ReleaseResource(handle);				}				else{					handle=GetIcon(kGenAppICON_ID);					PlotIcon(&dock_bounds,handle);//draw a square with the app name on it\					ReleaseResource(handle);				}			}			else //draw a blank square for the app without an icon..				CopyBits(&b,&thePort->portBits,&b.bounds,&dock_bounds,srcCopy,nil);			num_apps++;			dock_bounds.left+=kDockHSpace+kDockIconWidth+kDockHSpace;			dock_bounds.right+=kDockHSpace+kDockIconWidth+kDockHSpace;		}	}	//And Erase the rest of the dock (re-use dock_bounds var):	dock_bounds.bottom=(thePort->portRect).bottom;	dock_bounds.bottom=thePort->portRect.right;	EraseRect(&dock_bounds);}