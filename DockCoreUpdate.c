#include "DockCoreUpdate.h"#include "Aliases.h"#include "IconPlotting.h"/* Algo for 2.0's 'modern dock' Goal: Be able to show a dock that includes both what is runningand 'keep in dock' items and without duplication.Ideas:1. keep a list of running apps, and a list of favorite apps   ALWAYS plot fav apps list - but if one is running, plot the ¥ below it.   All new apps (non-fav) plot at end of the array   Therefore, plotted dock = fav apps (in order, w/¥ where needed), non-fav running apps.     When new app runs, check if it's in fav list. If so, mark as running DONE       If NOT, add to running(non fav) apps list (which get plotted at end)          BABY STEPS   - start by having two lists (faves and running) with no overlap. static at first,    keystroke to add later   - then see about moving from in<>out from both   - then combine the lists using dot icons or whatevs*/  /// Globals ///extern DockListNode *gVizDockListHEAD;extern unsigned short gVizDockListCnt;extern unsigned short gVizDockDeadFavesCnt;extern Boolean gShowSelf;extern unsigned short gMacDockItemNum, gDockIconHeight, gDockIconWidth, gDockCurSize,gDockHBorder;extern DTPBptrAndHandle DtpbPtrNHandle;#define kInitPsnCsum -627unsigned long gPsnHiLast = kInitPsnCsum;unsigned long gPsnLowLast = kInitPsnCsum;/* CalcSlotClicked * Takes a rectangle (typ the graphics port window rect) * and returns the dock slot that was clicked * Implied inputs include k and g variables dictating * the dock borders and icon width and dock spacings */ unsigned short CalcSlotClicked(Point *pt) { 	return (pt->h-gDockHBorder) / (kDockHSpace+gDockIconWidth+kDockHSpace); }/* FlashItem * Flashes a Dock item e.g. as UI feedback. * Number of flashes and pauses between flashes * are dictated by constants kBlinksOnClick and * constant kTicksBtwBlink. */void FlashItem(unsigned short item_num){	WindowPtr dockWin= thePort; //should be a better handle on the dock window	Rect itemRect;	long startTicks; //ticks = 1/60 of a second	short blinkCnt = 0;		itemRect.left = gDockHBorder+(kDockHSpace+gDockIconWidth+kDockHSpace)*item_num + kDockHSpace;	itemRect.right = itemRect.left + (gDockIconWidth);itemRect.top = kDockVSpace;	itemRect.bottom = itemRect.top + gDockIconHeight;	while(blinkCnt < kBlinksOnClick){		InvertRect(&itemRect);		startTicks = TickCount();		while((TickCount()-startTicks) < kTicksBtwBlink) ;		InvertRect(&itemRect);		startTicks = TickCount();		while((TickCount()-startTicks) < kTicksBtwBlink) ;		blinkCnt = blinkCnt+1;	}}/* Invertitem * Inverts the section corresponding to  * the item number specified by (item_num) * This can be used for UI feedback to user */void InvertItem(unsigned short item_num){	WindowPtr dockWin= thePort; //should be a better handle on the dock window	Rect itemRect;	itemRect.left = gDockHBorder+(kDockHSpace+gDockIconWidth+kDockHSpace)*item_num + kDockHSpace;	itemRect.right = itemRect.left + (gDockIconWidth);	itemRect.top = kDockVSpace;	itemRect.bottom = itemRect.top + gDockIconHeight;	InvertRect(&itemRect);}/* DockGetItemFSSpec  * Returns the FSSpecPtr to the FSSpec for the dock item #item_num */FSSpecPtr DockGetItemFSSpec(unsigned short item_num){	DockListNode* dListPtr = gVizDockListHEAD;	FSSpecPtr rv;	unsigned short i = 0;	for(i; i<item_num; i++)	  dListPtr = dListPtr -> next;	if(!dListPtr)	  return nil;	return &(dListPtr->dockRec.fsspec);}/* DockToggleFavoriteForItem  * Returns the FSSpecPtr to the FSSpec for the dock item #item_num */Boolean DockToggleFavoriteForItem(unsigned short item_num){	DockListNode* dListPtr = gVizDockListHEAD;	FSSpecPtr rv;	unsigned short i = 0;	for(i; i<item_num; i++)	  dListPtr = dListPtr -> next;	if(!dListPtr)	  return false;	dListPtr->dockRec.isFavorited = !(dListPtr->dockRec.isFavorited);	if(!(dListPtr->dockRec.isRunning) && !(dListPtr->dockRec.isFavorited))	{  //must delete this node!	  DeleteDockListNode(&dListPtr);	  gVizDockDeadFavesCnt--;	  UpdateRunningApps(true);	}    return true;}/* LaunchApp  * Tries to launch the app in slot (item_num). * Returns true if there was a non-MacDock app * in that slot or else false  */ Boolean LaunchApp(unsigned short item_num){	//do gestalt check gestaltOSAttr to see if sys supports the modern Launch records first...	LaunchParamBlockRec launchPBR;	if(gVizDockListCnt <= item_num) return false;			// Setup the record:	launchPBR.launchBlockID = extendedBlock; //const indicating you're launching	launchPBR.launchEPBLength = extendedBlockLen; //const specifying size, also from Processes.h	//no need to set the  .launchFileFlags because using extendedBlock	launchPBR.launchControlFlags = launchContinue;	launchPBR.launchAppSpec = DockGetItemFSSpec(item_num);	FlashItem(item_num);	LaunchApplication(&launchPBR);	return true;}/* RevealApp  * Tries to reveal the app in slot (item_num). * Returns true if successful, false otherwise (or if clicked on invalid slot) */ Boolean RevealApp(unsigned short item_num){	AEDesc fssDesc = {0};	AEDesc aeDesc = {0};	OSErr err;	long appSig;	AppleEvent appleEvent, reply;	LaunchParamBlockRec launchPBR;		//do gestalt check gestaltOSAttr to see if sys supports AppleScript w extensions...		if(gVizDockListCnt <= item_num) return false;	FlashItem(item_num);	appSig = 'MACS'; //Finder's app signature		//Next line creates a descriptor with the app signature of Finder:	err = AECreateDesc(typeApplSignature, (Ptr)(&appSig),				(Size)sizeof(appSig), &aeDesc);					//Create an AppleEvent directed at the Finder, where 'sope' is the Open keyword	err = AECreateAppleEvent('misc', 'mvis', 							&aeDesc,							kAutoGenerateReturnID, 1L,							&appleEvent);								err = AECreateDesc(typeFSS, (Ptr)(DockGetItemFSSpec(item_num)), (Size)sizeof(FSSpec), &fssDesc);		//Add the list as the parameter for appleEvent:	err = AEPutParamDesc(&appleEvent,keyDirectObject,&fssDesc);		//Send the AppleEvent	err = AESend( &appleEvent, &reply, 				kAENoReply+kAECanInteract+kAECanSwitchLayer,				kAENormalPriority,				kAEDefaultTimeout, 				nil, nil);					//Dispose descriptors	AEDisposeDesc(&aeDesc);		AEDisposeDesc(&fssDesc);	//And launch the finder w/o flashing icon:	launchPBR.launchBlockID = extendedBlock; //const indicating you're launching	launchPBR.launchEPBLength = extendedBlockLen; //const specifying size, also from Processes.h	//no need to set the  .launchFileFlags because using extendedBlock	launchPBR.launchControlFlags = launchContinue;	launchPBR.launchAppSpec = DockGetItemFSSpec(0);	LaunchApplication(&launchPBR);}/* AddApInSlotToFaves * Adds the app in slot # item_num to the favorite app list * Returns TRUE if successful, or FALSE if failed eg full faves list */Boolean AddAppInSlotToFaves(unsigned short item_num){	DockToggleFavoriteForItem(item_num);	FlashItem(item_num);	FlashItem(item_num);	FlashItem(item_num);	return TRUE;}/************* IsDockableProcess ************* * Inputs: *  procInfoRec - a valid ProcessInfoRec  *  pointing to a process.   *  No validity checking!! *	 * Outputs:	  *  Returns true if procInfoRec is a  *  process that should show up in the Dock ********************************************/Boolean IsDockableProcess(ProcessInfoRec *procInfoRec){  if(procInfoRec->processType == 'APPL'|| /* Applications */	procInfoRec->processType == 'FNDR'|| /* Finder */	procInfoRec->processType == 'APPC'|| /* Control Panel *///	procInfoRec->processType == 'INIT'|| /* Extensions e.g. File Sharing */	procInfoRec->processType == 'dfil') /* Desk Accessory */	if(procInfoRec->processSignature != kMacDockAppSignature||gShowSelf)		return true;  return false;}/********* CheckForRunningAppChange ********* * Returns true if there has been a change in  * number of running apps * since the last time it was checked. * Must account not for what apps  * are runing not just * app count (e.g. by PSN check) * Inputs: *  global variables indicating PSN Hi/Low checksums *	 * Outputs:	 *	num_apps updated to # of cur running apps *  PsnLowChecksum updated for cur running apps *  PsnHiChecksum updated for cur running apps *	Returns true if there has been a change ********************************************/Boolean CheckForRunningAppChange(short *num_apps,	unsigned long *PsnLowCheckSum, 	unsigned long *PsnHiCheckSum){	//unsigned long PsnHiCheckSum, PsnLowCheckSum;	ProcessSerialNumber PSN;	ProcessInfoRec procInfoRec;	OSErr osErr;	Str255 procName;	FSSpec appFileLoc; //includes member .vRefNum the vol ref number		//unsigned long PsnHiCheckSum, PsnLowCheckSum;	PSN.highLongOfPSN = 0; //Init PSN//	PSN.lowLongOfPSN = kNoProcess;		*num_apps = 0;	*PsnHiCheckSum = 0;	*PsnLowCheckSum = 0;		procInfoRec.processAppSpec = &appFileLoc;	procInfoRec.processName = (StringPtr)(&procName);	procInfoRec.processInfoLength = sizeof(ProcessInfoRec);	while(GetNextProcess(&PSN) == noErr)	{		osErr = GetProcessInformation(&PSN,(ProcessInfoRecPtr)(&procInfoRec));			if(IsDockableProcess(&procInfoRec))			{				(*num_apps)++; //figure out how many apps are now running				(*PsnHiCheckSum) += PSN.highLongOfPSN;				(*PsnLowCheckSum) += PSN.lowLongOfPSN;			}	}	// Any change in what apps are running and we need to redraw:	if(gPsnHiLast != *PsnHiCheckSum ||		gPsnLowLast != *PsnLowCheckSum)	//if check indicates changes in apps	{		return true;	}	else		return false;}/*UpdateRunningApps*/void UpdateRunningApps(Boolean ForceRedraw){	ProcessInfoRec procInfoRec;	Str255 procName;	FSSpec appFileLoc; //includes member .vRefNum the vol ref number	OSErr osErr;	ProcessSerialNumber PSN;	DTPBRec DTPBRecord;	short num_apps = 0;	Rect dock_bounds;	Handle handle;	unsigned long PsnHiCheckSum, PsnLowCheckSum;	Boolean tmpBool = false, foundMatch;			AliasHandle aliasHndl;	unsigned short i,tmpInt;	DockListNode* dListPtr;	DockRecord dockRec;		dock_bounds.top=kDockVSpace; 	dock_bounds.left=gDockHBorder+kDockHSpace;	dock_bounds.bottom=dock_bounds.top+gDockIconHeight; 	dock_bounds.right = dock_bounds.left+gDockIconWidth;	procInfoRec.processAppSpec = &appFileLoc;	procInfoRec.processName = (StringPtr)(&procName);	procInfoRec.processInfoLength = sizeof(ProcessInfoRec);	PSN.highLongOfPSN = 0; //Init PSN//	PSN.lowLongOfPSN = kNoProcess;	/**** Setup ParamBlock ****/	//PBRecord.ioCompletion = nil;	/**** Setup DTPBRecord ****/	DTPBRecord.ioCompletion = nil;	DTPBRecord.ioNamePtr = nil;	DTPBRecord.ioDTRefNum = 0; //needs desktop db ref #!!!	DTPBRecord.ioTagInfo = 0; //must be 0, RESERVED	DtpbPtrNHandle.run_count = 0;	DtpbPtrNHandle.DTPBptr = &DTPBRecord;	DTPBRecord.ioDTBuffer = nil;						//Future: check that this desktop has a desktop database else quit	num_apps = 0;	PsnHiCheckSum = 0;	PsnLowCheckSum = 0;	//	Check if there has been a change in running apps	//while(num_apps == 0) //somehow this causes major slowdowns	tmpBool = CheckForRunningAppChange(&num_apps, &PsnLowCheckSum,											&PsnHiCheckSum);	gPsnHiLast = PsnHiCheckSum;	gPsnLowLast = PsnLowCheckSum;	//for each running app, find a matching vizdock app	  // if find a match that's not running, mark as running	  // if find a match that IS running, no action needed	//if can't find a vizdock app, add it as a new vizdock running at end    if(tmpBool && num_apps >= gVizDockListCnt-gVizDockDeadFavesCnt) //find the new process(es) and set to run	{	  PSN.highLongOfPSN = 0;	  PSN.lowLongOfPSN = kNoProcess;	  while(GetNextProcess(&PSN) == noErr)	  {	    osErr = GetProcessInformation(&PSN,(ProcessInfoRecPtr)(&procInfoRec));	    if(!IsDockableProcess(&procInfoRec)) continue;	    dListPtr = gVizDockListHEAD;	    foundMatch = false;	    while(dListPtr)	    {           if(EqualString(procInfoRec.processAppSpec->name,		                 (dListPtr->dockRec).fsspec.name, false, false) &&		      procInfoRec.processAppSpec->vRefNum==(dListPtr->dockRec).fsspec.vRefNum &&		      procInfoRec.processAppSpec->parID==(dListPtr->dockRec).fsspec.parID)		  { //matched this process to this list item		    if(!(dListPtr->dockRec.isRunning))		    {  //this a fav'd that just started running		      (dListPtr->dockRec).isRunning = true; //set it to running		      gVizDockDeadFavesCnt --; //now it's not dead!		    }		    		    foundMatch = true; //found a hit! can break early		    break;		  }	      if(dListPtr->next) dListPtr = dListPtr->next;	      else break; //reached end of list, but don't go to the null next	    }	    if(!foundMatch)	    {//never found a match, must add!	      //add to Vizible Dock List:		  dockRec.fsspec = *(procInfoRec.processAppSpec);		  dockRec.ioFileCreator = procInfoRec.processSignature;		  dockRec.ioFileType = procInfoRec.processType;		  dockRec.isRunning = true;		  dockRec.isFavorited = false;		  if(gVizDockListCnt!=0)		  {		    dListPtr->next = MakeDockListNodeWithDummyItem();	        dListPtr->next->prev = dListPtr;			dListPtr = dListPtr->next;		  }		  dListPtr->dockRec = dockRec;		  gVizDockListCnt++;		  DtpbPtrNHandle.run_count = 0;	    }	  }	}    if(tmpBool && num_apps <= gVizDockListCnt-gVizDockDeadFavesCnt) //find the now-dead processes	{	  dListPtr = gVizDockListHEAD;	  while(dListPtr)	  {	     if(!(dListPtr->dockRec.isRunning))	     {	       dListPtr = dListPtr->next;	       continue;	     }		 PSN.highLongOfPSN = 0;		 PSN.lowLongOfPSN = kNoProcess;         foundMatch = false;		 while(GetNextProcess(&PSN) == noErr)		 {		   osErr = GetProcessInformation(&PSN,(ProcessInfoRecPtr)(&procInfoRec));		   if(!IsDockableProcess(&procInfoRec)) 		     continue;           if(EqualString(procInfoRec.processAppSpec->name,		                 (dListPtr->dockRec).fsspec.name, false, false) &&		      procInfoRec.processAppSpec->vRefNum==(dListPtr->dockRec).fsspec.vRefNum &&		      procInfoRec.processAppSpec->parID==(dListPtr->dockRec).fsspec.parID)		   { //matched this process to this list item		      foundMatch = true; //found a hit! can break early		      break;		   }	     }          if(!foundMatch)	     {//never found a match, this is the dead process!	       dListPtr->dockRec.isRunning = false;	       //NOTE we don't touch .isFavorited	       if(!(dListPtr->dockRec.isFavorited))	       {	        DeleteDockListNode(&dListPtr);	       }	       else{	         dListPtr = dListPtr->next;	         gVizDockDeadFavesCnt ++;	         ForceRedraw = true;	       }           DtpbPtrNHandle.run_count = 0;	     }	     else	       dListPtr = dListPtr->next;       }	}	if(ForceRedraw || tmpBool || num_apps != gVizDockListCnt-gVizDockDeadFavesCnt)	{		if(!gDockCurSize || gDockCurSize != gVizDockListCnt)		{			UpdateDockSize(gVizDockListCnt);			//return;//updating the dock size will trigger an updateEvent				//that will go through the dock redraw				//this avoids 2xRedraws (once for the change in app count				//and again for the resized window!)		}		PSN.highLongOfPSN = 0;		PSN.lowLongOfPSN = kNoProcess;		EraseRect(&(thePort->portRect));		dListPtr = gVizDockListHEAD;		while(dListPtr)		{			DTPBRecord.ioFileCreator = dListPtr->dockRec.ioFileCreator;			DTPBRecord.ioFileType = dListPtr->dockRec.ioFileType;			DTPBRecord.ioVRefNum = dListPtr->dockRec.fsspec.vRefNum;			PBDTGetPath((DTPBPtr)(&DTPBRecord));			PlotIconMethod(&dock_bounds,0,0, IconGetter,(Ptr)(&DtpbPtrNHandle));//allocates handle inside...				if(DTPBRecord.ioResult != noErr)			{ 				EraseRect(&dock_bounds);				if(procInfoRec.processSignature == 'MACS')				{//	draw Finder icon, stored internally					PlotIconID(&dock_bounds,0,0,kFinderICON_ID);				}				else if(DtpbPtrNHandle.run_count >= 2)				{//	if got the b&w icon but didn't find color, plot b&w:					PlotIcon(&dock_bounds,DtpbPtrNHandle.MaskDataInUse);				}				else				{//plot a generic app icon					PlotIconID(&dock_bounds,0,0,kGenAppICON_ID);				}			}			DtpbPtrNHandle.run_count = 0;			if(dListPtr->dockRec.isRunning)			{						    Rect rect;				MoveTo(dock_bounds.left+gDockIconWidth/2-2,dock_bounds.bottom+1);				PenSize(1,1);PenPat(black);				//LineTo(dock_bounds.left+gDockIconWidth/2+2,dock_bounds.bottom+3);				SetRect(&rect,dock_bounds.left+gDockIconWidth/2-2,dock_bounds.bottom+2,						dock_bounds.left+gDockIconWidth/2+2, dock_bounds.bottom+6);				PaintOval(&rect);			}									dock_bounds.left+=gDockIconWidth+kDockHSpace+kDockHSpace;			dock_bounds.right = dock_bounds.left+gDockIconWidth;			dListPtr = dListPtr->next;			}				for(i=gDockHBorder; i<gVizDockListCnt*(i+kDockHSpace+gDockIconWidth+kDockHSpace) && 0; i=i+kDockHSpace+gDockIconWidth+kDockHSpace)		{			MoveTo(i, 0);			PenPat(gray); PenSize(1,1);			LineTo(i, 40);		}		//Plot delimeter line from running to faves, for fun for now		//MoveTo(dock_bounds.left-kDockHSpace-1, dock_bounds.bottom-3);		//PenPat(gray); PenSize(2,1);		//LineTo(dock_bounds.left-kDockHSpace-1, dock_bounds.top+3);		//And now plot a trash spot :-D	}	return;}void DeleteDockListNode(DockListNode **dListPtr){  DockListNode *tmpPtr = *dListPtr;  if(!tmpPtr)    return;    gVizDockListCnt--;  if(!tmpPtr->prev)  {//deleting the head node    if(tmpPtr->next)      tmpPtr->next->prev = tmpPtr->prev;//null ok    //else this head is the only ptr, we'll kill it anyway    *dListPtr = tmpPtr->next; //update what dListPtr points to    gVizDockListHEAD = *dListPtr;    DisposePtr(tmpPtr); //Free memory        return;  }    if(!tmpPtr->next)  {//deleting the tail node, which is not the head node    tmpPtr->prev->next = tmpPtr->next;    *dListPtr = tmpPtr->next;    DisposePtr(tmpPtr); //Free memory    return;  }  //non-head, non-tail target:  tmpPtr->prev->next = tmpPtr->next;  tmpPtr->next->prev = tmpPtr->prev;  *dListPtr = tmpPtr->next;  DisposePtr(tmpPtr);}DockListNode* MakeDockListNodeWithDummyItem(){  DockListNode* listPtr;  listPtr = (DockListNode*)NewPtr(sizeof(DockListNode));    listPtr -> next = nil;  listPtr -> prev = nil;  return listPtr;}/* AddDummyListNode *  Adds a new Dock list item to the end of the list pointed to by listPtr *  If listPtr is nil, Initializes it as a single-element list *  THE NEW NODE WILL HAVE A DUMMY DOCKREC!!! *  Moves listPtr to point to the (new) last list node. */Boolean AddDummyListNodeToListEnd(DockListNode *listPtr){  if(!listPtr){    listPtr = MakeDockListNodeWithDummyItem();  }  while(listPtr->next)    listPtr = listPtr->next;  listPtr->next = MakeDockListNodeWithDummyItem();  listPtr->next->prev = listPtr;  listPtr->next->next = nil;  listPtr = listPtr->next;  return true;}/* AddNewDockRecordToListEnd *  Adds a new Dock list item to the end of the list pointed to by listPtr *  If listPtr is nil, Initializes it as a single-element list *  Makes the last item in this list contain dockRec *  Moves listPtr to point to the (new) last list node. */Boolean AddDockRecordToListEnd(DockListNode* listPtr, DockRecord* dockRec){  AddDummyListNodeToListEnd(listPtr);  listPtr->dockRec = *dockRec;  return true;}void LoadPrefs(){  OSErr myErr;  short myVRef, myRef, myRefNum;  long myDirID;  FSSpec mySpec;  Str255 myName;  Handle myHand;  const unsigned short kPrefID = 128;  #define rRsrcMcdkType 'mcdk'  short i=1, cntSavedFaves;  Handle aliasHndl, dockRecHndl;  FSSpec fspec;  Boolean tmpBool;  DockListNode *dListPtr;  DockRecord dockRec;  dListPtr = gVizDockListHEAD;  GetIndString(myName, kPrefID, 1);  myErr = FindFolder(kOnSystemDisk, kPreferencesFolderType,  					 kDontCreateFolder, &myVRef, &myDirID);  if(noErr == myErr)    myErr = FSMakeFSSpec(myVRef, myDirID, myName, &mySpec);  if(fnfErr == myErr)//file not found, create it!  {    FSpCreateResFile(&mySpec, kMacDockAppSignature, kPreferencesFolderType, smSystemScript);    myRefNum = FSpOpenResFile(&mySpec, fsCurPerm);   }  else if(noErr == myErr)  {    myRefNum = FSpOpenResFile(&mySpec, fsCurPerm);     cntSavedFaves = Count1Resources(rRsrcMcdkType);    if(cntSavedFaves != Count1Resources(rAliasType)){      //corrupted favorites, clear out the mcdk and alis resources and warn!    }    gVizDockDeadFavesCnt = cntSavedFaves;    //gVizDockListCnt=0; //ALREADY INITIALIZED IN InitDock()    for(i=1; i<=cntSavedFaves; i++)    {	  //Read the resources or data fork for saved aliases for faves	  aliasHndl = Get1IndResource(rAliasType, i);	  dockRecHndl = Get1IndResource(rRsrcMcdkType, i);	  if(noErr == ResError())	  {	    ResolveAlias(nil, (AliasHandle)aliasHndl, &fspec, &tmpBool);	    //Add this gFsspec as a new dList item, make it favorited, mark as not running(? updated later)		//add to Vizible Dock List:		dockRec.fsspec = fspec;		dockRec.ioFileCreator = ((DockRecord*)*dockRecHndl)->ioFileCreator;		dockRec.ioFileType = ((DockRecord*)*dockRecHndl)->ioFileType;		dockRec.isRunning = false; //assume false tho it may be true -> would be updated in first run		dockRec.isFavorited = true; //remains a favorite!		if(gVizDockListCnt!=0){		  dListPtr->next = MakeDockListNodeWithDummyItem();		  dListPtr->next->prev = dListPtr;		  dListPtr = dListPtr->next;		}		dListPtr->dockRec = dockRec;		gVizDockListCnt++;	  }	}    for(i=1; i<=cntSavedFaves; i++)    {	  //Read the resources or data fork for saved aliases for faves	  aliasHndl = Get1IndResource(rAliasType, 1);	  dockRecHndl = Get1IndResource(rRsrcMcdkType, 1);	  if(noErr == ResError())	  {	    RmveResource(aliasHndl);	   	    ChangedResource(dockRecHndl);        WriteResource(dockRecHndl);	    RmveResource(dockRecHndl);        ChangedResource(aliasHndl);        WriteResource(aliasHndl);	  }	}  }    CloseResFile(myRefNum);}/*InitDock - first run of populating the viz dock list*/void InitDock(){	ProcessInfoRec procInfoRec;	Str255 procName;	FSSpec appFileLoc; //includes member .vRefNum the vol ref number	OSErr osErr;	ProcessSerialNumber PSN;	DTPBRec DTPBRecord;	short num_apps = 0;	Handle handle;	unsigned long PsnHiCheckSum, PsnLowCheckSum;	Boolean tmpBool = false;		//	AliasHandle aliasHndl;	unsigned short tmpInt;	DockListNode *dListPtr;	DockRecord dockRec;		gVizDockListHEAD = MakeDockListNodeWithDummyItem();	dListPtr = gVizDockListHEAD;		procInfoRec.processAppSpec = &appFileLoc;	procInfoRec.processName = (StringPtr)(&procName);	procInfoRec.processInfoLength = sizeof(ProcessInfoRec);	PSN.highLongOfPSN = 0; //Init PSN//	PSN.lowLongOfPSN = kNoProcess;	/**** Setup DTPBRecord ****/	DTPBRecord.ioCompletion = nil;	DTPBRecord.ioNamePtr = nil;	DTPBRecord.ioDTRefNum = 0; //needs desktop db ref #!!!	DTPBRecord.ioTagInfo = 0; //must be 0, RESERVED	DtpbPtrNHandle.run_count = 0;	DtpbPtrNHandle.DTPBptr = &DTPBRecord;	DTPBRecord.ioDTBuffer = nil;			gVizDockListCnt=0;		num_apps = 0;	PsnHiCheckSum = 0;	PsnLowCheckSum = 0;	//	Check if there has been a change in running apps	tmpBool = CheckForRunningAppChange(&num_apps, &PsnLowCheckSum,											&PsnHiCheckSum);	gPsnHiLast = PsnHiCheckSum;	gPsnLowLast = PsnLowCheckSum;		if(tmpBool)	{		PSN.highLongOfPSN = 0;		PSN.lowLongOfPSN = kNoProcess;		while(GetNextProcess(&PSN) == noErr)		{			osErr = GetProcessInformation(&PSN,(ProcessInfoRecPtr)(&procInfoRec));			if(IsDockableProcess(&procInfoRec))			{				//look up its icon and get ready to update the dock				DTPBRecord.ioFileCreator = procInfoRec.processSignature; //get the creator from the signature				DTPBRecord.ioFileType = procInfoRec.processType;//get the app icon				DTPBRecord.ioVRefNum = procInfoRec.processAppSpec->vRefNum;				PBDTGetPath((DTPBPtr)(&DTPBRecord));				if(noErr != DTPBRecord.ioResult)				{					SysBeep(10);				 	ExitToShell();				}								//add to Vizible Dock List:				dockRec.fsspec = *(procInfoRec.processAppSpec);				dockRec.ioFileCreator = DTPBRecord.ioFileCreator;				dockRec.ioFileType = DTPBRecord.ioFileType;				dockRec.isRunning = true;				dockRec.isFavorited = false;				if(gVizDockListCnt!=0){				  dListPtr->next = MakeDockListNodeWithDummyItem();				  dListPtr->next->prev = dListPtr;				  dListPtr = dListPtr->next;				}				dListPtr->dockRec = dockRec;				gVizDockListCnt++;				DtpbPtrNHandle.run_count = 0;							}			if(procInfoRec.processType == 'FNDR')				break; //we just want to load the finder then load preferences!		}		LoadPrefs();		//RESET the Psn record so you force a full update on first Update Dock run:		gPsnHiLast = 0;		gPsnLowLast = 0;			return;//LEFT OFF HERE --- do i plot here? i should track VizDock size... and adjust window?				//DO PLOT FAVORITES		//TODO add a check here to see if it's worth replotting the faves or not	}}