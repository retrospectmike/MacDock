//Mike Dock **The App**#include"GestaltEqu.h"#include<Values.h>#include<AppleEvents.h>#include "DockCoreUpdate.h"#include "Files.h"#define kBaseResID 128#define kAboutWinID 129#define kMoveToFront (WindowPtr)-1L #define mApple	kBaseResID#define iAbout 1#define mFile kBaseResID+1#define iUpdateAppList	1#define iQuit	3#define kSleep 20L#define kGestaltMask 1L //apple events checking#define SetHighByte(longNum) (longNum |=0xFF000000)#define ClearHighByte(longNum) (longNum &= 0x00FFFFFF)Boolean gDone;void ToolBoxInit();void WindowInit();void MenuBarInit();void EventLoop();void DoEvent(EventRecord *eventPtr);void HandleNull(EventRecord *eventPtr);void HandleMouseDown(EventRecord *eventPtr);void HandleMenuChoice(long menuChocie);void HandleAppleChoice(short item);void HandleFileChoice(short item);void UpdateRunningApps();void DoUpdate(EventRecord *eventPtr);//AppleEvent handlers:pascal OSErr DoOpenApp(AppleEvent theAppleEvent, AppleEvent reply, long refCon);pascal OSErr DoQuitApp(AppleEvent theAppleEvent, AppleEvent reply, long refCon);pascal OSErr DoPrintDoc(AppleEvent theAppleEvent, AppleEvent reply, long refCon);pascal OSErr DoOpenDoc(AppleEvent theAppleEvent, AppleEvent reply, long refCon);void EventInit();void main(){	ToolBoxInit();	WindowInit();	MenuBarInit();	EventInit();		EventLoop();}void ToolBoxInit(){	InitGraf(&thePort);	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(nil);	InitCursor();}/**** MenuBarInit() ****/void MenuBarInit(){	Handle menuBar;	MenuHandle menu;	ControlHandle control;	//OSErr myErr;	long feature;		menuBar = GetNewMBar(kBaseResID);	SetMenuBar(menuBar);	menu = GetMHandle(mApple);	AddResMenu(menu,'DRVR');	DrawMenuBar();}void WindowInit(){	WindowPtr window;	window = GetNewWindow(kBaseResID,nil,kMoveToFront);	if(window==nil){SysBeep(10);ExitToShell();}	SetPort(window);	//BackPat(white); //would require use of masks etc to do it right..}void AboutWindow(){	WindowPtr window;	return; //need to make the whole program aware of windows!	//need to make the main window update separately from this one!	//need to draw onto this one!	window = GetNewWindow(kAboutWinID,nil,kMoveToFront);	if(window==nil){SysBeep(10);ExitToShell();}	SetPort(window);	ShowWindow(window);		//BackPat(white); //would require use of masks etc to do it right..}void EventLoop(){	EventRecord event;	gDone = false;	while(gDone == false)	{		if(WaitNextEvent(everyEvent, &event, kSleep, nil))			DoEvent(&event);		else UpdateRunningApps();//HandleNull(&event);	}}void DoEvent(EventRecord *eventPtr){  char theChar;  switch(eventPtr->what){  	case kHighLevelEvent:  		AEProcessAppleEvent(eventPtr);  		break;    case mouseDown:    	HandleMouseDown(eventPtr);    	break;    case keyDown:    case autoKey:    	theChar = eventPtr->message & charCodeMask;    	if((eventPtr->modifiers & cmdKey) != 0)    		HandleMenuChoice(MenuKey(theChar));    	break;    case updateEvt:    	DoUpdate(eventPtr);    	break;  }}/***** HandleNull *******/void HandleNull(EventRecord* eventPtr){	/*probably do something about updating with running app icons*/	UpdateRunningApps();}/**** HandleMouseDown *****/void HandleMouseDown(EventRecord *eventPtr){	WindowPtr whichWindow;	GrafPtr oldPort;	short thePart;	long menuChoice;	ControlHandle control;	short ignored;	thePart = FindWindow(eventPtr->where, &whichWindow);	switch(thePart){		case inMenuBar:			menuChoice = MenuSelect(eventPtr->where);			HandleMenuChoice(menuChoice);			break;		case inSysWindow:			SystemClick(eventPtr, whichWindow);			break;		case inContent:			SetPort(whichWindow);			GlobalToLocal(&eventPtr->where);			if(FindControl(eventPtr->where, whichWindow, &control)){				; //no controls in my program..			}			else{				LaunchApp((eventPtr->where).h / (kDockHSpace+kDockIconWidth+kDockHSpace));			}			break;		case inDrag:			//DragWindow(whichWindow, eventPtr->where,			//			&screenBits.bounds);			break;	}}void HandleMenuChoice(long menuChoice){	short menu;	short item;	if(menuChoice!=0)	{		menu = HiWord(menuChoice);		item = LoWord(menuChoice);				switch(menu)		{			case mApple:				HandleAppleChoice(item);				break;			case mFile:				HandleFileChoice(item);				break;		}		HiliteMenu(0);	}}void HandleAppleChoice(short item){	MenuHandle appleMenu;	Str255 accName;	short accNumber;	switch(item){		case iAbout:			AboutWindow();SysBeep(20);			break;		default:			appleMenu = GetMHandle(mApple);			GetItem(appleMenu,item,accName);			accNumber = OpenDeskAcc(accName);			break;	}}void HandleFileChoice(short item){	switch(item){		case iUpdateAppList:			UpdateRunningApps();			break;		case iQuit:			gDone = true;			break;	}}void DoUpdate(EventRecord *eventPtr){	WindowPtr window;	window = (WindowPtr) eventPtr->message;	BeginUpdate(window);	//EraseRect( &gClockRect);	//MoveTo( kClockLeft, kClockTop);	//DrawString( timeString );	//DrawControls( window );	EndUpdate( window );	}void EventInit(){	OSErr err;	long feature;		err = Gestalt(gestaltAppleEventsAttr,&feature);	if(err!=noErr){SysBeep(10);return;}	else{		if(!(feature & (kGestaltMask << gestaltAppleEventsPresent)))		{SysBeep(10);return;}	}	err = AEInstallEventHandler( kCoreEventClass, kAEOpenApplication, DoOpenApp, 0L, false);	if(err!=noErr){SysBeep(10);return;}	err = AEInstallEventHandler( kCoreEventClass, kAEOpenDocuments, DoOpenDoc, 0L, false);	if(err!=noErr){SysBeep(10);return;}	err = AEInstallEventHandler( kCoreEventClass, kAEPrintDocuments, DoPrintDoc, 0L, false);	if(err!=noErr){SysBeep(10);return;}	err = AEInstallEventHandler( kCoreEventClass, kAEQuitApplication, DoQuitApp, 0L, false);	if(err!=noErr){SysBeep(10);return;}}pascal OSErr DoOpenApp(AppleEvent theAppleEvent, AppleEvent reply, long refCon){	UpdateRunningApps();	return noErr;}pascal OSErr DoQuitApp(AppleEvent theAppleEvent, AppleEvent reply, long refCon){	return noErr;}pascal OSErr DoOpenDoc(AppleEvent theAppleEvent, AppleEvent reply, long refCon){	return noErr;}pascal OSErr DoPrintDoc(AppleEvent theAppleEvent, AppleEvent reply, long refCon){	return noErr;} 