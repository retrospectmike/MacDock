//Mike Dock **The App**#include"GestaltEqu.h"#include<Values.h>#include<AppleEvents.h>#include "DockCoreUpdate.h"#include "Files.h"#define kBaseResID 128#define kAboutWinID 129#define kMoveToFront (WindowPtr)-1L #define mApple	kBaseResID#define iAbout 1#define mFile kBaseResID+1#define iUpdateAppList	1#define iQuit	3#define mOptions mFile+1#define iAutoHide 1#define kSleep 20L#define kGestaltMask 1L //apple events checking#define SetHighByte(longNum) (longNum |=0xFF000000)#define ClearHighByte(longNum) (longNum &= 0x00FFFFFF)Boolean gDone, gDockHidden;void ToolBoxInit();void WindowInit();void MenuBarInit();void EventLoop();void DoEvent(EventRecord *eventPtr);void HandleNull(EventRecord *eventPtr);void HandleMouseDown(EventRecord *eventPtr);void HandleMenuChoice(long menuChocie);void HandleAppleChoice(short item);void HandleFileChoice(short item);void HandleOptionsChoice(short item);void UpdateRunningApps();void DoUpdate(EventRecord *eventPtr);void HandleMouseMove(EventRecord *eventPtr);void HandleMouseUp(EventRecord *eventPtr, PointPtr lastMouseDown);void EventInit();void HideDock();void ShowDock();//AppleEvent handlers:pascal OSErr DoOpenApp(AppleEvent theAppleEvent, AppleEvent reply, long refCon);pascal OSErr DoQuitApp(AppleEvent theAppleEvent, AppleEvent reply, long refCon);pascal OSErr DoPrintDoc(AppleEvent theAppleEvent, AppleEvent reply, long refCon);pascal OSErr DoOpenDoc(AppleEvent theAppleEvent, AppleEvent reply, long refCon);Boolean gAutoHide = false;void main(){	ToolBoxInit();	WindowInit();	MenuBarInit();	EventInit();		EventLoop();}void ToolBoxInit(){	InitGraf(&thePort);	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(nil);	InitCursor();}/**** MenuBarInit() ****/void MenuBarInit(){	Handle menuBar;	MenuHandle menu;	ControlHandle control;	//OSErr myErr;	long feature;		menuBar = GetNewMBar(kBaseResID);	SetMenuBar(menuBar);	menu = GetMHandle(mApple);	AddResMenu(menu,'DRVR');	DrawMenuBar();}void WindowInit(){	WindowPtr window;	GDHandle screen;	short screen_res_x, screen_res_y;	short dockWinHeight,dockWinWidth;	window = GetNewWindow(kBaseResID,nil,kMoveToFront);	//MOVE WINDOW TO BOTTOM CENTER OF SCREEN DYNAMICALLY ACCOUNT FOR CUR SCREEN SIZE:	dockWinWidth = window->portRect.right-thePort->portRect.left;	dockWinHeight = window->portRect.bottom-thePort->portRect.top;	screen = GetMainDevice();	if(window==nil){SysBeep(10);ExitToShell();}	MoveWindow(window,				(**screen).gdRect.right/2-dockWinWidth/2,				(**screen).gdRect.bottom-dockWinHeight,				true);	ShowWindow(window);	SetPort(window);	gDockHidden = false;}void AboutWindow(){	WindowPtr window;	return; //need to make the whole program aware of windows!	//need to make the main window update separately from this one!	//need to draw onto this one!	window = GetNewWindow(kAboutWinID,nil,kMoveToFront);	if(window==nil){SysBeep(10);ExitToShell();}	SetPort(window);	ShowWindow(window);		//BackPat(white); //would require use of masks etc to do it right..}void EventLoop(){	EventRecord event;	gDone = false;	while(gDone == false)	{//create the initial Region to be inside the dock to trigger osEvt	//for mouse if it moves		if(WaitNextEvent(everyEvent, &event, kSleep, nil))			DoEvent(&event);		else UpdateRunningApps();//HandleNull(&event);	}}void HideDock(){	WindowPtr window;	GDHandle screen;	short screen_res_x, screen_res_y;	short dockWinHeight,dockWinWidth;	window = thePort;	//MOVE WINDOW TO BOTTOM CENTER OF SCREEN DYNAMICALLY ACCOUNT FOR CUR SCREEN SIZE:	dockWinWidth = window->portRect.right-thePort->portRect.left;	dockWinHeight = window->portRect.bottom-thePort->portRect.top;	screen = GetMainDevice();	if(window==nil){SysBeep(10);ExitToShell();}	MoveWindow(window,			(**screen).gdRect.right/2-dockWinWidth/2,			(**screen).gdRect.bottom-dockWinHeight/2,			true);	gDockHidden = true;}void ShowDock(){	WindowPtr window;	GDHandle screen;	short screen_res_x, screen_res_y;	short dockWinHeight,dockWinWidth;	window = thePort;	//MOVE WINDOW TO BOTTOM CENTER OF SCREEN DYNAMICALLY ACCOUNT FOR CUR SCREEN SIZE:	dockWinWidth = window->portRect.right-thePort->portRect.left;	dockWinHeight = window->portRect.bottom-thePort->portRect.top;	screen = GetMainDevice();	if(window==nil){SysBeep(10);ExitToShell();}	MoveWindow(window,			(**screen).gdRect.right/2-dockWinWidth/2,			(**screen).gdRect.bottom-dockWinHeight,			true);	gDockHidden = false;}#define osEvtMsgBitShift 24void HandleOsEvt(EventRecord *eventPtr){	if((eventPtr->message)>>osEvtMsgBitShift == suspendResumeMessage){		//Suspend-Resume:;		if((eventPtr->message)&0x0001){ //Resume			GlobalToLocal(&eventPtr->where);			if((eventPtr->where).v > 0 && (eventPtr->where).v < kDockIconHeight+2*kDockVSpace )			{	//Resumed right into the Dock window				if(!LaunchApp((eventPtr->where).h / 							  (kDockHSpace+kDockIconWidth+kDockHSpace)))				{					if(gAutoHide && gDockHidden)						ShowDock(); 				}			}			else{ //Resumed outside of the Dock 				if(gAutoHide && gDockHidden)					ShowDock();			}		}		else{ //Suspend			//Consider 'hiding the dock now:			if(gAutoHide && !gDockHidden)				HideDock();		}	}	else if((eventPtr->message)>>24 == suspendResumeMessage){		}	switch(eventPtr->message){		case mouseMovedMessage:			HandleMouseMove(eventPtr);			//SysBeep(10);			break;		case suspendResumeMessage:			//SysBeep(10);			break;	}}void HandleMouseMove(EventRecord *eventPtr){	WindowPtr whichWindow;	GrafPtr oldPort;	short thePart;	thePart = FindWindow(eventPtr->where, &whichWindow);	switch(thePart){		case inContent:			SetPort(whichWindow);			GlobalToLocal(&eventPtr->where);			LaunchApp((eventPtr->where).h / (kDockHSpace+kDockIconWidth+kDockHSpace));			//HighlightItem((eventPtr->where).h / (kDockHSpace+kDockIconWidth+kDockHSpace));			break;	}}void DoEvent(EventRecord *eventPtr){  char theChar;  static Point lastMouseDownPt;    switch(eventPtr->what){  	case kHighLevelEvent:  		AEProcessAppleEvent(eventPtr);  		break;  	case osEvt:  		HandleOsEvt(eventPtr);  		//if(eventPtr->message & mouseMovedMessage;  		break;    case mouseDown:    	HandleMouseDown(eventPtr);    	lastMouseDownPt = eventPtr->where; //in local coordinates by now    	break;    case mouseUp:    	//HandleMouseUp(eventPtr,&lastMouseDownPt);    	break;    case keyDown:    case autoKey:    	theChar = eventPtr->message & charCodeMask;    	if((eventPtr->modifiers & cmdKey) != 0)    		HandleMenuChoice(MenuKey(theChar));    	break;    case updateEvt:    	DoUpdate(eventPtr);    	break;  }}/***** HandleNull *******/void HandleNull(EventRecord* eventPtr){	/*probably do something about updating with running app icons*/	UpdateRunningApps();}/**** HandleMouseUp *****/void HandleMouseUp(EventRecord *eventPtr, PointPtr lastMouseDown){	WindowPtr whichWindow;	GrafPtr oldPort;	short thePart;	ControlHandle control;	short lastMouseDownItemNum, curMouseDownItemNum;		thePart = FindWindow(eventPtr->where, &whichWindow);		lastMouseDownItemNum = lastMouseDown->h / (kDockHSpace+kDockIconWidth+kDockHSpace);	GlobalToLocal(&eventPtr->where);	curMouseDownItemNum = (eventPtr->where).h / (kDockHSpace+kDockIconWidth+kDockHSpace);	switch(thePart){		case inContent:			SetPort(whichWindow);			if(FindControl(eventPtr->where, whichWindow, &control)){				//no controls in my program..			}			else{				if(lastMouseDownItemNum == curMouseDownItemNum)				{					LaunchApp(curMouseDownItemNum);				}				else				{					InvertItem(lastMouseDownItemNum);				}			}			break;		case inDrag:			//DragWindow(whichWindow, eventPtr->where,			//			&screenBits.bounds);			break;	}}/**** HandleMouseDown *****/void HandleMouseDown(EventRecord *eventPtr){	WindowPtr whichWindow;	GrafPtr oldPort;	short thePart;	long menuChoice;	ControlHandle control;	short ignored;	thePart = FindWindow(eventPtr->where, &whichWindow);	switch(thePart){		case inMenuBar:			menuChoice = MenuSelect(eventPtr->where);			HandleMenuChoice(menuChoice);			break;		case inSysWindow:			SystemClick(eventPtr, whichWindow);			break;		case inContent:			SetPort(whichWindow);			GlobalToLocal(&eventPtr->where);			if(FindControl(eventPtr->where, whichWindow, &control)){				; //no controls in my program..			}			else{ //mouse down in content of Dock								LaunchApp((eventPtr->where).h / (kDockHSpace+kDockIconWidth+kDockHSpace));				//InvertItem((eventPtr->where).h / (kDockHSpace+kDockIconWidth+kDockHSpace));			}			break;		case inDrag:			//DragWindow(whichWindow, eventPtr->where,			//			&screenBits.bounds);			break;	}}void HandleMenuChoice(long menuChoice){	short menu;	short item;	if(menuChoice!=0)	{		menu = HiWord(menuChoice);		item = LoWord(menuChoice);				switch(menu)		{			case mApple:				HandleAppleChoice(item);				break;			case mFile:				HandleFileChoice(item);				break;			case mOptions:				HandleOptionsChoice(item);				break;		}		HiliteMenu(0);	}}void HandleAppleChoice(short item){	MenuHandle appleMenu;	Str255 accName;	short accNumber;	switch(item){		case iAbout:			AboutWindow();SysBeep(20);			break;		default:			appleMenu = GetMHandle(mApple);			GetItem(appleMenu,item,accName);			accNumber = OpenDeskAcc(accName);			break;	}}void HandleFileChoice(short item){	switch(item){		case iUpdateAppList:			UpdateRunningApps();			break;		case iQuit:			gDone = true;			break;	}}void HandleOptionsChoice(short item){	MenuHandle menu;	switch(item){		case iAutoHide:			menu = GetMenu(mOptions);			if(!gAutoHide)				CheckItem(menu, iAutoHide, true);			else				CheckItem(menu, iAutoHide, false);						gAutoHide = !gAutoHide;			break;	}}void DoUpdate(EventRecord *eventPtr){	WindowPtr window;	window = (WindowPtr) eventPtr->message;	BeginUpdate(window);	//EraseRect( &gClockRect);	//MoveTo( kClockLeft, kClockTop);	//DrawString( timeString );	//DrawControls( window );	EndUpdate( window );	}void EventInit(){	OSErr err;	long feature;		err = Gestalt(gestaltAppleEventsAttr,&feature);	if(err!=noErr){SysBeep(10);return;}	else{		if(!(feature & (kGestaltMask << gestaltAppleEventsPresent)))		{SysBeep(10);return;}	}	err = AEInstallEventHandler( kCoreEventClass, kAEOpenApplication, DoOpenApp, 0L, false);	if(err!=noErr){SysBeep(10);return;}	err = AEInstallEventHandler( kCoreEventClass, kAEOpenDocuments, DoOpenDoc, 0L, false);	if(err!=noErr){SysBeep(10);return;}	err = AEInstallEventHandler( kCoreEventClass, kAEPrintDocuments, DoPrintDoc, 0L, false);	if(err!=noErr){SysBeep(10);return;}	err = AEInstallEventHandler( kCoreEventClass, kAEQuitApplication, DoQuitApp, 0L, false);	if(err!=noErr){SysBeep(10);return;}}pascal OSErr DoOpenApp(AppleEvent theAppleEvent, AppleEvent reply, long refCon){	UpdateRunningApps();	return noErr;}pascal OSErr DoQuitApp(AppleEvent theAppleEvent, AppleEvent reply, long refCon){	return noErr;}pascal OSErr DoOpenDoc(AppleEvent theAppleEvent, AppleEvent reply, long refCon){	return noErr;}pascal OSErr DoPrintDoc(AppleEvent theAppleEvent, AppleEvent reply, long refCon){	return noErr;} 